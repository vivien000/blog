<!doctype html>
<html>

<head>

  <title>
    
      Fast, High-Fidelity LLM Decoding with Regex Constraints | Unsupervised Thoughts
    
  </title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">

  <link rel="stylesheet" href="https://vivien000.github.io/blog/assets/css/main.css">
  <link rel="stylesheet" href="https://vivien000.github.io/blog/assets/css/syntax.css">
  <!-- Use Atom -->
  <!-- <link type="application/atom+xml" rel="alternate" href="https://vivien000.github.io/blog/rss-feed.xml" title="Unsupervised Thoughts" /> -->
  <!-- Use RSS-2.0 -->
  <link href="https://vivien000.github.io/blog/rss-feed.xml" type="application/rss+xml" rel="alternate" title="Unsupervised Thoughts | A blog on machine learning"/>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Quattrocento+Sans">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>

  <!-- Google Analytics -->
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SFFMKRY3GE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SFFMKRY3GE');
</script>


  <!-- Use Jekyll SEO plugin -->
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Fast, High-Fidelity LLM Decoding with Regex Constraints | Unsupervised Thoughts</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Fast, High-Fidelity LLM Decoding with Regex Constraints" />
<meta name="author" content="Vivien" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Constraining the text generated by an LLM is essential for developing robust LLM applications. For example, a developer may require LLM responses to adhere to a specific JSON or YAML schema so that they are comprehensive and reliably parseable." />
<meta property="og:description" content="Constraining the text generated by an LLM is essential for developing robust LLM applications. For example, a developer may require LLM responses to adhere to a specific JSON or YAML schema so that they are comprehensive and reliably parseable." />
<link rel="canonical" href="https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html" />
<meta property="og:url" content="https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html" />
<meta property="og:site_name" content="Unsupervised Thoughts" />
<meta property="og:image" content="https://vivien000.github.io/blog/typewriter.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-22T00:00:00+01:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://vivien000.github.io/blog/typewriter.png" />
<meta property="twitter:title" content="Fast, High-Fidelity LLM Decoding with Regex Constraints" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html"},"url":"https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html","image":"https://vivien000.github.io/blog/typewriter.png","author":{"@type":"Person","name":"Vivien"},"headline":"Fast, High-Fidelity LLM Decoding with Regex Constraints","dateModified":"2024-02-22T00:00:00+01:00","datePublished":"2024-02-22T00:00:00+01:00","description":"Constraining the text generated by an LLM is essential for developing robust LLM applications. For example, a developer may require LLM responses to adhere to a specific JSON or YAML schema so that they are comprehensive and reliably parseable.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


</head>


<body>

  <div class="container">
    <header class="masthead">
  <h3 class="masthead-title">
    <a href="https://vivien000.github.io/blog/">Unsupervised Thoughts</a>
    <small class="masthead-subtitle">A blog on machine learning</small>
    <div class="menu">
  <nav class="menu-content">
    
      <a href="https://vivien000.github.io/blog/menu/about.html">About</a>
    
  </nav>
  <nav class="social-icons">
    
  
  
    <a href="https://www.github.com/vivien000" target="_blank"><i class="fa fa-github" aria-hidden="true"></i></a>
  

  
  
    <a href="https://twitter.com/vivien000000" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  

  
  
    <a href="http://vivien000.github.io/blog/rss-feed.xml" target="_blank"><i class="fa fa-rss-square" aria-hidden="true"></i></a>
  

  
  
    <a href="mailto:vivien@melix.net" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
  

  </nav>
</div>

  </h3>
</header>


    <div class="post-container">
      <h1>
  Fast, High-Fidelity LLM Decoding with Regex Constraints
</h1>


  <img src="https://vivien000.github.io/blog/assets/img/typewriter.png">


<p><strong>Constraining the text generated by an LLM</strong> is essential for developing robust LLM applications. For example, a developer may require LLM responses to adhere to a specific JSON or YAML schema so that they are comprehensive and reliably parseable.</p>

<p><strong>Powerful tools and methods</strong> <a class="citation" href="#beurer2022prompting">(Beurer-Kellner et al., 2022; Lundberg &amp; Ribeiro, 2023; Willard &amp; Louf, 2023; Zheng et al., 2023)</a> have been published in the past year to address this need. Notably, the <a href="https://github.com/outlines-dev/outlines">open source library</a> <script type="math/tex">\texttt{Outlines}</script> implements an efficient method <a class="citation" href="#willard2023efficient">(Willard &amp; Louf, 2023)</a> that ensures <strong>compliance with an arbitrary regex</strong>.</p>

<p>In this blog post, I propose two <strong>novel, fast, high-fidelity alternatives</strong> to this method. Specifically, I will:</p>
<ul>
  <li>Present the principle of <script type="math/tex">\texttt{Outlines}</script><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> and discuss how allowing improper token sequences (i.e. token sequences that do not correspond to the tokenization of a string) can skew the probability distribution of the LLM and hinder the decoding speed;</li>
  <li>Introduce <script type="math/tex">\texttt{DirectMerge}</script>, a method that maintains guaranteed compliance while only generating proper token sequences. <script type="math/tex">\texttt{DirectMerge}</script> is valid for all tokenizers based on a merge table and in particular for the very popular Byte Pair Encoding tokenizers <a class="citation" href="#sennrich-etal-2016-neural">(Sennrich et al., 2016)</a>;</li>
  <li>Propose <script type="math/tex">\texttt{CartesianMerge}</script>, a variant of <script type="math/tex">\texttt{DirectMerge}</script> that scales better with the complexity of the regex;</li>
  <li>Discuss the execution time of <script type="math/tex">\texttt{CartesianMerge}</script> and show how this execution time can be significantly reduced in the case of a JSON or YAML schema constraint.</li>
</ul>

<p>This blog post comes with a <a href="https://github.com/vivien000/regex-constrained-decoding/blob/main/technical_appendix.pdf">technical appendix</a> formalizing and proving the algorithms. Additionally, a <a href="https://github.com/vivien000/regex-constrained-decoding/blob/main/implementation_and_experiments.ipynb">Python notebook</a> with implementations of <script type="math/tex">\texttt{DirectMerge}</script> and <script type="math/tex">\texttt{CartesianMerge}</script>, along with additional empirical results, is available.</p>

<ul id="markdown-toc">
  <li><a href="#deterministic-finite-automata-and-constrained-decoding" id="markdown-toc-deterministic-finite-automata-and-constrained-decoding">Deterministic Finite Automata and Constrained Decoding</a></li>
  <li><a href="#three-challenges-due-to-improper-token-sequences" id="markdown-toc-three-challenges-due-to-improper-token-sequences">Three Challenges due to Improper Token Sequences</a>    <ul>
      <li><a href="#challenge-1-skewed-probability-distribution" id="markdown-toc-challenge-1-skewed-probability-distribution">Challenge #1: Skewed Probability Distribution</a></li>
      <li><a href="#challenge-2-self-intoxication" id="markdown-toc-challenge-2-self-intoxication">Challenge #2: Self-Intoxication</a></li>
      <li><a href="#challenge-3-missed-speedup-opportunities" id="markdown-toc-challenge-3-missed-speedup-opportunities">Challenge #3: Missed Speedup Opportunities</a></li>
    </ul>
  </li>
  <li><a href="#ensuring-both-compliance-and-proper-tokenization" id="markdown-toc-ensuring-both-compliance-and-proper-tokenization">Ensuring Both Compliance and Proper Tokenization</a></li>
  <li><a href="#scaling-with-the-complexity-of-the-regex" id="markdown-toc-scaling-with-the-complexity-of-the-regex">Scaling with the Complexity of the Regex</a></li>
  <li><a href="#is-it-fast-enough" id="markdown-toc-is-it-fast-enough">Is it Fast Enough?</a></li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<h1 id="deterministic-finite-automata-and-constrained-decoding">Deterministic Finite Automata and Constrained Decoding</h1>

<p>I now briefly explain the principle of <script type="math/tex">\texttt{Outlines}</script>. Please read the original paper <a class="citation" href="#willard2023efficient">(Willard &amp; Louf, 2023)</a> or this <a href="https://blog.dottxt.co/coalescence.html">blog post</a> for a more comprehensive overview.</p>

<p>As a <strong>preprocessing step</strong>, <script type="math/tex">\texttt{Outlines}</script> converts a <strong>character-level deterministic finite automaton (DFA)</strong> testing whether a string matches a regex (cf. Figure 1a) into a <strong>token-level DFA testing whether a token sequence is decoded in a string matching the regex</strong> (cf. Figure 1b):</p>
<ul>
  <li>the <strong>states</strong>, including the start state and the accept states, remain the same;</li>
  <li>the <strong>alphabet</strong> of the token-level DFA is the tokenizer’s vocabulary;</li>
  <li>the <strong>transition function</strong> of the token-level DFA is the extended transition function of the character-level DFA restricted to the tokenizer’s vocabulary. For example with the example of Figure 1b, there is an <script type="math/tex">\texttt{abb}</script> transition from <script type="math/tex">\texttt{0}</script> to <script type="math/tex">\texttt{1}</script> because if we start from <script type="math/tex">\texttt{0}</script> on the character-level DFA and successively see <script type="math/tex">\texttt{a}</script>, <script type="math/tex">\texttt{b}</script> and <script type="math/tex">\texttt{b}</script>, we’ll end up in state <script type="math/tex">\texttt{1}</script>.</li>
</ul>

<p><img src="https://vivien000.github.io/blog/assets/img/directmerge-outlines.png" alt="`&quot;a*b*&quot;` DFA" /></p>
<div class="caption">Figure 1. Top left: character-level DFA for \(\texttt{a*b*}\), top right: token-level DFA returned by \(\texttt{Outlines}\) for the same regex, bottom: token masking at decoding time.</div>

<p>At <strong>decoding time</strong>, the DFA is used to determine, for each new token, which potential tokens are allowed. For this and starting from the initial state of the DFA, we determine the <strong>allowed tokens</strong> with the outgoing transitions from the current state, <strong>apply the corresponding mask to the next token probabilities</strong> and renormalize these probabilities. We can then sample a new token and update the state of the DFA.</p>

<p>For example, let’s imagine that the tokens <script type="math/tex">\texttt{aaaa}</script>, <script type="math/tex">\texttt{aa}</script> and <script type="math/tex">\texttt{ab}</script> have already been generated. Starting from state <script type="math/tex">\texttt{0}</script>, we remained in state <script type="math/tex">\texttt{0}</script> with <script type="math/tex">\texttt{aaaa}</script> and <script type="math/tex">\texttt{aa}</script> but transitioned to state <script type="math/tex">\texttt{1}</script> with <script type="math/tex">\texttt{ab}</script>. The tokens now allowed are simply those with an outgoing transition from state <script type="math/tex">\texttt{1}</script>, i.e. <script type="math/tex">\texttt{b}</script> and <script type="math/tex">\texttt{bb}</script>. We then consider the next token probabilities of these two tokens and we renormalize them so that they sum to 1.</p>

<h1 id="three-challenges-due-to-improper-token-sequences">Three Challenges due to Improper Token Sequences</h1>

<p>The token sequences potentially generated with <script type="math/tex">\texttt{Outlines}</script> are exactly those that are decoded into a string matching the regex. This includes <strong>token sequences that do not result from the tokenization of a string</strong>. We call them <strong>improper token sequences</strong> below.</p>

<p>Consider the regex: <script type="math/tex">\texttt{"boolean: ((true)}\mid\texttt{(false))"}</script>. While there are only two strings matching this regex, the corresponding DFA returned by <script type="math/tex">\texttt{Outlines}</script> has 16 states and 48 transitions (Figure 2). For example, the first token is chosen among <script type="math/tex">\texttt{boolean}</script>, <script type="math/tex">\texttt{bool}</script>, <script type="math/tex">\texttt{bo}</script> and <script type="math/tex">\texttt{b}</script>.</p>

<p><img src="https://vivien000.github.io/blog/assets/img/directmerge-outlines-example.png" alt="DFA built by Outlines for `&quot;boolean: ((true)|(false))&quot;`" /></p>
<div class="caption">Figure 2. DFA built by \(\texttt{Outlines}\) for the \(\texttt{"boolean: ((true)|(false))"}\) regex</div>

<p>In contrast, as we will see in the following sections, the DFA built by <script type="math/tex">\texttt{DirectMerge}</script> and <script type="math/tex">\texttt{CartesianMerge}</script> only accepts the token sequences resulting from the tokenization of compliant strings and it has only 5 states and 4 transitions (Figure 3).</p>

<p><img src="https://vivien000.github.io/blog/assets/img/directmerge-boolean.png" alt="DFA built by DirectMerge and CartesianMerge for `&quot;boolean: ((true)|(false))&quot;`" /></p>
<div class="caption">Figure 3. DFA built by \(\texttt{DirectMerge}\) and \(\texttt{CartesianMerge}\) for the \(\texttt{"boolean: ((true)|(false))"}\) regex</div>

<h2 id="challenge-1-skewed-probability-distribution">Challenge #1: Skewed Probability Distribution</h2>

<p>The permissiveness of <script type="math/tex">\texttt{Outlines}</script> with improper token sequences <strong>may significantly distort the probability distribution of the LLM</strong>, beyond what is strictly necessary to enforce the regex constraint.</p>

<p>To illustrate this, let’s imagine that we generate a continuation of the prompt <code class="highlighter-rouge">Question: What is the first name of the US president who was a member of the Sigma Alpha Epsilon fraternity?\nAnswer:</code> with the regex constraint <script type="math/tex">\texttt{"( William)}\mid \texttt{( Theodore)"}</script> (the true answer is William like <a href="https://en.wikipedia.org/wiki/William_McKinley">William McKinley</a>, <a href="https://en.wikipedia.org/wiki/Theodore_Roosevelt">Theodore Roosevelt</a>’s predecessor).</p>

<p>When the text generation is unconstrained, we can compute the probability along all token sequences leading to one of the two possible answers. If we do so with <script type="math/tex">\texttt{Mistral-7B}</script> and a temperature equal to 1, we get <script type="math/tex">\frac{P(\texttt{" William"})}{P(\texttt{" William"})+P(\texttt{" Theodore"})} = 0.85879</script> and notice that almost all the probability mass for these two answers comes from proper token sequences (99.8586% for <script type="math/tex">\texttt{" Theodore"}</script> and 99.9997% for <script type="math/tex">\texttt{" William"}</script>).</p>

<p>If we constrain the text generation with <script type="math/tex">\texttt{Outlines}</script> and multinomial sampling as a decoding strategy, any prefix of <script type="math/tex">\texttt{" William"}</script> and <script type="math/tex">\texttt{" Theodore"}</script> will be accepted as the first token and determine the answer (if this first token is not the blank space). For example, the token <script type="math/tex">\texttt{" The"}</script> can be selected as the first token and in this case, the answer will necessarily be <script type="math/tex">\texttt{" Theodore"}</script>. As a result, the probability to generate <script type="math/tex">\texttt{" Theodore"}</script> will be the sum of generating <script type="math/tex">\texttt{" T"}</script>, <script type="math/tex">\texttt{" Th"}</script>, <script type="math/tex">\texttt{" The"}</script>, etc. as the first token, even though these first tokens, except <script type="math/tex">\texttt{" Theod"}</script> almost never lead to <script type="math/tex">\texttt{" Theodore"}</script> and <script type="math/tex">\texttt{" Theodore"}</script> will be significantly boosted by the sole virtue of having a very common token, <script type="math/tex">\texttt{" The"}</script>, as a prefix. Indeed, <script type="math/tex">\frac{P(\texttt{" William"})}{P(\texttt{" William"})+P(\texttt{" Theodore"})} = 0.52852</script> in this case.</p>

<p>With <script type="math/tex">\texttt{DirectMerge}</script> and <script type="math/tex">\texttt{CartesianMerge}</script>, only the tokens corresponding to the tokenization of the possible answers are taken into account (e.g. <script type="math/tex">\texttt{" The"}</script> is ignored). The conditional probability, <script type="math/tex">\frac{P(\texttt{" William"})}{P(\texttt{" William"})+P(\texttt{" Theodore"})} = 0.85872</script>, is very close the one in the unconstrained case, which makes sense given that the LLM spontaneously generates proper token sequences a large majority of the time.</p>

<h2 id="challenge-2-self-intoxication">Challenge #2: Self-Intoxication</h2>

<p>Another concern is that the tokens generated are fed back to the LLM to select the following ones. During its pretraining and depending whether subword regularization techniques like BPE-Dropout <a class="citation" href="#provilkov-etal-2020-bpe">(Provilkov et al., 2020)</a> have been used, an LLM was never or rarely exposed to improper token sequences so <strong>this LLM may not properly interpret the newly added tokens</strong> and this can impact the quality of its output.</p>

<h2 id="challenge-3-missed-speedup-opportunities">Challenge #3: Missed Speedup Opportunities</h2>

<p>As suggested by two recent <a href="https://blog.dottxt.co/coalescence.html">blog</a> <a href="https://lmsys.org/blog/2024-02-05-compressed-fsm/">posts</a>, <script type="math/tex">\texttt{Outlines}</script> offers opportunities to accelerate decoding.</p>

<p>Let’s go back to the DFA provided by <script type="math/tex">\texttt{DirectMerge}</script> and <script type="math/tex">\texttt{CartesianMerge}</script> on Figure 3. There is only one outgoing transition from states <script type="math/tex">\texttt{0}</script> and <script type="math/tex">\texttt{1}</script>. This means that we don’t even need to compute the next token probability when we reach these states since there is only one possible token. We can then generate the whole text in just one LLM call. Meanwhile, the DFA built with <script type="math/tex">\texttt{Outlines}</script> for the same regex on Figure 2 has 16 states but only 3 states with one outgoing transition (states 6, 7 and 13). There are then <strong>much fewer opportunities to skip computationally expensive LLM calls</strong>. Moreover, there are many potential paths that are much longer than three transitions. This can also slow down the decoding.</p>

<h1 id="ensuring-both-compliance-and-proper-tokenization">Ensuring Both Compliance and Proper Tokenization</h1>

<p>We can now focus on <script type="math/tex">\texttt{DirectMerge}</script>. Even though its aims are slightly different, <script type="math/tex">\texttt{DirectMerge}</script> shares the same overall approach as <script type="math/tex">\texttt{Outlines}</script>: it derives a <strong>token-level DFA</strong> from a character-level DFA recognizing the regex and this token-level DFA is used to identify allowed tokens at decoding time.</p>

<p><script type="math/tex">\texttt{DirectMerge}</script> applies to <strong>tokenizers based on a merge table</strong>, like Byte Pair Encoding tokenizers <a class="citation" href="#sennrich-etal-2016-neural">(Sennrich et al., 2016)</a>. Encoding a string with such tokenizers consists of converting the string into a sequence of single-letter tokens and then performing an ordered list of merge operations. Each of these merge operations is defined by two tokens (e.g. <script type="math/tex">\texttt{a}</script> and <script type="math/tex">\texttt{b}</script>) and merge all the corresponding pairs of consecutive tokens, starting from the left of the current token sequence.</p>

<table>
  <tbody>
    <tr>
      <td>Initial string</td>
      <td><script type="math/tex">\texttt{aaaabaacac}</script></td>
    </tr>
    <tr>
      <td>Conversion to a sequence of single-letter tokens</td>
      <td><script type="math/tex">\texttt{a a a a b a a c a c}</script></td>
    </tr>
    <tr>
      <td>Token sequence after <script type="math/tex">\texttt{merge}(\texttt{a}, \texttt{b})</script></td>
      <td><script type="math/tex">\texttt{a a a }\underline{\texttt{ab}}\texttt{ a a c a c}</script></td>
    </tr>
    <tr>
      <td>Token sequence after <script type="math/tex">\texttt{merge}(\texttt{a}, \texttt{a})</script></td>
      <td><script type="math/tex">\underline{\texttt{aa}}\texttt{ a ab }\underline{\texttt{aa}}\texttt{ c a c}</script></td>
    </tr>
    <tr>
      <td>Final token sequence after <script type="math/tex">\texttt{merge}(\texttt{a}, \texttt{c})</script></td>
      <td><script type="math/tex">\texttt{aa a ab aa c }\underline{\texttt{ac}}</script></td>
    </tr>
  </tbody>
</table>

<div class="caption">Table 1. Tokenization of the string \(\texttt{aaaabaacac}\) with the merge table \([(\texttt{a}, \texttt{b}), (\texttt{a}, \texttt{a}), (\texttt{a}, \texttt{c})]\). The order of the merge operations and the order of the letters in the string both affect the final token sequence.</div>

<p>With <script type="math/tex">\texttt{DirectMerge}</script>, we start with the character-level DFA and we apply a <strong>series of simple transformations for each merge operation</strong>. Let us consider the case of an <script type="math/tex">(a, b)</script> merge operation with <script type="math/tex">a \neq b</script>. <script type="math/tex">\texttt{DirectMerge}</script> affects each state <script type="math/tex">S</script> with one or several incoming <script type="math/tex">a</script> transitions and one outgoing <script type="math/tex">b</script> transition and its impact depends on two criteria:</p>
<ol>
  <li><strong>Has <script type="math/tex">S</script> non-<script type="math/tex">a</script> incoming transitions or is <script type="math/tex">S</script> the start state?</strong></li>
  <li><strong>Has <script type="math/tex">S</script> non-<script type="math/tex">b</script> outgoing transitions or is <script type="math/tex">S</script> an accept state?</strong></li>
</ol>

<p>More precisely and if the outgoing <script type="math/tex">b</script> transition from <script type="math/tex">S</script> leads to <script type="math/tex">S_b</script>, the transformations applied to state <script type="math/tex">S</script> are the following:</p>
<ul>
  <li>Replace each incoming <script type="math/tex">a</script> transition by an <script type="math/tex">ab</script> transition to <script type="math/tex">S_b</script></li>
  <li>If both criteria are false (cf. Figure 4a):
    <ul>
      <li>Remove <script type="math/tex">S</script></li>
    </ul>
  </li>
  <li>If Criterion 1 is false and Criterion 2 is true:
    <ul>
      <li>Remove the outgoing <script type="math/tex">b</script> transition</li>
    </ul>
  </li>
  <li>If Criterion 1 is true and Criterion 2 is false:
    <ul>
      <li>Remove all incoming <script type="math/tex">a</script> transitions</li>
    </ul>
  </li>
  <li>If both criteria are true  (cf. Figure 4c):
    <ul>
      <li>Add a state <script type="math/tex">S'</script></li>
      <li>Redirect all incoming <script type="math/tex">a</script> transitions to <script type="math/tex">S'</script></li>
      <li>Copy all non-<script type="math/tex">b</script> transitions of <script type="math/tex">S</script> and add them to <script type="math/tex">S'</script></li>
      <li>Make <script type="math/tex">S'</script> an accept state if <script type="math/tex">S</script> is an accept state</li>
    </ul>
  </li>
</ul>

<p><img src="https://vivien000.github.io/blog/assets/img/directmerge-examples.png" alt="DirectMerge when two different tokens are merged" /></p>
<div class="caption">Figure 4. Examples of the transformations to apply in case of an \((a, b)\) merge operation with \(a \neq b\). Left: situation before \(\texttt{DirectMerge}\), right: situation after \(\texttt{DirectMerge}\).</div>

<p>The case of merge operations with two identical tokens is more challenging because not all pairs of matching tokens should be merged. For example, on the fourth row of Table 1 above, the second and third <script type="math/tex">a</script> are not merged because the merge operation is applied left-to-right and the second <script type="math/tex">a</script> is already merged with the first <script type="math/tex">a</script>. You can find the <strong>description of <script type="math/tex">\texttt{DirectMerge}</script> in the case <script type="math/tex">a = b</script> and the correctness proof for both cases in the <a href="https://github.com/vivien000/regex-constrained-decoding/blob/main/technical_appendix.pdf">technical appendix</a></strong>.</p>

<h1 id="scaling-with-the-complexity-of-the-regex">Scaling with the Complexity of the Regex</h1>

<p><script type="math/tex">\texttt{DirectMerge}</script> guarantees both compliance with the regex constraint and proper tokenization. However, <script type="math/tex">\texttt{DirectMerge}</script> removes or adds states and transitions and in some unfavorable circumstances, <strong>the number of states and transitions may become overwhelmingly large</strong>.</p>

<p>Fortunately, with <script type="math/tex">\texttt{CartesianMerge}</script>, <strong>we can efficiently simulate the DFA created by <script type="math/tex">\texttt{DirectMerge}</script> without explicitly building it</strong>. We can indeed notice that the target language is the intersection of the set of all token sequences decoded into strings matching the regex and the set of all proper token sequences. Both of these sets are regular languages and we already know how to build the corresponding DFAs, with <script type="math/tex">\texttt{Outlines}</script> for the first one and with <script type="math/tex">\texttt{DirectMerge}</script> applied to the <script type="math/tex">\texttt{".*"}</script> regex for the second one. Furthermore, as opposed to the DFA returned by <script type="math/tex">\texttt{DirectMerge}</script>, they will not become uncontrolably large as the regex becomes more complex. <script type="math/tex">\texttt{Outlines}</script> does not add any state to the character-level DFA and the DFA returned by <script type="math/tex">\texttt{DirectMerge}</script> with <script type="math/tex">\texttt{".*"}</script> happens to have interesting properties that make it easy to compute and compress (cf. the <a href="https://github.com/vivien000/regex-constrained-decoding/blob/main/technical_appendix.pdf">technical appendix</a> for more details).</p>

<p><img src="https://vivien000.github.io/blog/assets/img/directmerge-venn.png" alt="Cross product operation with a DFA" /></p>
<div class="caption">Figure 5. The target language is the intersection of two regular languages and we already know how to build the DFAs for both of them.</div>

<p>Once we have built these two DFAs, we can keep track of their respective states at decoding time and the allowed tokens are in the intersection of their respective sets of allowed tokens.</p>

<p>However, knowing which tokens are valid transitions in both DFAs is not enough because we also need to <strong>check that the tokens generated can eventually lead to a token sequence decoded into a string matching the regex</strong>. This was not an issue before because both <script type="math/tex">\texttt{Outlines}</script> and <script type="math/tex">\texttt{DirectMerge}</script> generate token-level DFAs whose states are all relevant (i.e. on a path between the start state and an accept state) as long as the initial character-level DFA only has relevant states. The pairs of states that are valid can be computed with a breadth-first exploration starting from the pair of start states and then from the pairs of accept states with reverse transitions.</p>

<h1 id="is-it-fast-enough">Is it Fast Enough?</h1>

<p>Table 2 reports the execution time of the various steps of <script type="math/tex">\texttt{CartesianMerge}</script> for a sample of JSON strings from the <script type="math/tex">\texttt{glaive-function-calling-v2}</script> dataset. The delay of the first step is negligible because this activity only needs to be executed once for a given tokenizer and its outcome will be useful for all future regex. The second and fourth steps also add little overhead while <strong>the third step is the performance bottleneck</strong>.</p>

<table>
  <thead>
    <tr>
      <th>Step</th>
      <th>Activity</th>
      <th>Mean duration (seconds)</th>
      <th>Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Compute the DFA recognizing proper token sequences with <script type="math/tex">\texttt{DirectMerge}</script> (preprocessing)</td>
      <td>20.9</td>
      <td>Only once for a given tokenizer</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Compute the DFA recognizing the token sequences decoded into strings matching the regex with <script type="math/tex">\texttt{Outlines}</script> (preprocessing)</td>
      <td>0.687</td>
      <td>Only once for a given regex</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Identify relevant pairs of states (preprocessing)</td>
      <td>27.3</td>
      <td>Only once for a given regex</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Build the token mask (decoding)</td>
      <td>0.00153</td>
      <td>At each decoding step</td>
    </tr>
  </tbody>
</table>

<div class="caption">Table 2. Execution time of the various steps of \(\texttt{CartesianMerge}\) on a sample of 1000 JSON strings from the \(\texttt{glaive-function-calling-v2}\) <a href="https://huggingface.co/datasets/glaiveai/glaive-function-calling-v2">dataset</a>.</div>

<p>The latency of the third step remains limited if the regex constraint is used a large number of times but it may become an issue when a new regex is expected to be provided only at the time of decoding. It would typically be the case if an LLM provider offers a feature similar to OpenAI’s function calling. However, when the real goal is to adhere to a JSON or YAML schema, we can significantly shorten the preprocessing.</p>

<p>Oftentimes in practical situations, there will be parts of the regex surrounded by two delimiters with which they cannot merge. This is particularly interesting for us because we then know that the portion of the DFA representing these parts is unaffected by all other parts of the regex. Let’s call these situations <strong>Vegas configurations</strong> (because <em>what happens between the delimiters stays between the delimiters</em>).</p>

<p>For example with the Mistral-7B tokenizer, whatever string starting with a blank space and delimited by a colon and a line break is a Vegas configuration and this is of course very useful for YAML schemas.</p>

<p>Vegas configurations can be leveraged in two ways, as illustrated by Figure 6:</p>
<ul>
  <li>if we realize that the same Vegas configuration appears several times in the regex, we can compute and store the corresponding portion of the DFA only once;</li>
  <li>if the variable parts of the regex we use often correspond to a limited number of Vegas configuration, we can build <strong>a library of these Vegas configurations</strong>, store the corresponding portions of the DFA and directly use them needed. With JSON or YAML schemas, the library would typically include the Vegas configurations of the common types (strings, numbers, dates…).</li>
</ul>

<p><img src="https://vivien000.github.io/blog/assets/img/directmerge-vegas.png" alt="Vegas configuration" /></p>
<div class="caption">Figure 6. The DFA corresponding to Vegas configurations, i.e. repeated parts surrounded by two delimiters with which they cannot merge, can be computed and stored only once. Top: naive implementation of \(\texttt{CartesianMerge}\), bottom: implementation of \(\texttt{CartesianMerge}\) taking advantage of Vegas configurations.</div>

<h1 id="conclusion">Conclusion</h1>

<p>In this blog post, I introduced two alternatives to <script type="math/tex">\texttt{Outlines}</script>. <script type="math/tex">\texttt{DirectMerge}</script> and <script type="math/tex">\texttt{CartesianMerge}</script> also <strong>guarantee compliance with a regex constraint</strong> while <strong>accelerating decoding</strong> and <strong>mitigating the risks of distortions<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> of the language model distribution</strong>.</p>

<p>It is unclear how often such distortions may happen. However it is easy to find examples of them and should they happen in practice, they would probably go unnoticed. Given that uncertainty and the decoding speedup, <script type="math/tex">\texttt{CartesianMerge}</script> should be a <strong>no-regret option</strong> for most constrained decoding needs.</p>

<p>Beyond constrained decoding, it would also be interesting to assess whether the fact that models sometimes generate improper token sequences affect their performance. If it were the case, <script type="math/tex">\texttt{CartesianMerge}</script> may be used to enforce proper tokenization.</p>

<p><em>Thanks to the authors of the papers mentioned below, in particular to Luca Beurer-Kellner for a helpful discussion, and to the contributors of the various resources used (inter alia, <script type="math/tex">\texttt{outlines}</script>, <script type="math/tex">\texttt{interegular}</script>, <script type="math/tex">\texttt{transformers}</script> and <script type="math/tex">\texttt{glaive-function-calling-v2}</script>).</em></p>

<p><em>If you want to cite this blog post, you are welcome to use the following BibTeX entry:</em></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@misc{Tran-Thien_2024,
title={Fast, High-Fidelity LLM Decoding with Regex Constraints},
url={https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html},
journal={Unsupervised Thoughts (blog)},
author={Tran-Thien, Vivien},
year={2024}
}
</code></pre></div></div>

<h1 id="references">References</h1>

<ol class="bibliography"><li><span id="beurer2022prompting">Beurer-Kellner, L., Fischer, M., &amp; Vechev, M. (2022). Prompting Is Programming: A Query Language For Large Language Models. <i>PLDI ’23</i>.</span></li>
<li><span id="guidance">Lundberg, S., &amp; Ribeiro, M. T. C. et al. (2023). <i>Guidanceai/guidance: A guidance language for controlling large language models</i>. https://github.com/guidance-ai/guidance</span></li>
<li><span id="willard2023efficient">Willard, B. T., &amp; Louf, R. (2023). <i>Efficient Guided Generation for Large Language Models</i>.</span></li>
<li><span id="zheng2023efficiently">Zheng, L., Yin, L., Xie, Z., Huang, J., Sun, C., Yu, C. H., Cao, S., Kozyrakis, C., Stoica, I., Gonzalez, J. E., Barrett, C., &amp; Sheng, Y. (2023). <i>Efficiently Programming Large Language Models using SGLang</i>.</span></li>
<li><span id="sennrich-etal-2016-neural">Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Neural Machine Translation of Rare Words with Subword Units. In K. Erk &amp; N. A. Smith (Eds.), <i>Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</i> (pp. 1715–1725). Association for Computational Linguistics. https://doi.org/10.18653/v1/P16-1162</span></li>
<li><span id="provilkov-etal-2020-bpe">Provilkov, I., Emelianenko, D., &amp; Voita, E. (2020). BPE-Dropout: Simple and Effective Subword Regularization. In D. Jurafsky, J. Chai, N. Schluter, &amp; J. Tetreault (Eds.), <i>Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics</i> (pp. 1882–1892). Association for Computational Linguistics. https://doi.org/10.18653/v1/2020.acl-main.170</span></li></ol>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>In this blog post, I abusively use <script type="math/tex">\texttt{Outlines}</script> to denote the underlying method <a class="citation" href="#willard2023efficient">(Willard &amp; Louf, 2023)</a> rather than the open source library. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>As illustrated in the second section, distortion here means a discrepancy between the probability distribution with constrained decoding — <script type="math/tex">P_\text{constrained}(.)</script> — and the probability distribution with unconstrained decoding conditioned on the satisfaction of the constraint — <script type="math/tex">P_\text{unconstrained}(.\mid\mathcal{S})</script> (where <script type="math/tex">S</script> is the set of the compliant strings). <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>


<span class="post-date">
  Written on
  
  February
  22nd
    ,
  2024
  by
  
    Vivien
  
</span>

<div class="post-date">Feel free to share!</div>
  <div class="sharing-icons">
    <a href="https://twitter.com/intent/tweet?text=Fast, High-Fidelity LLM Decoding with Regex Constraints&amp;url=https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
    <a href="https://www.facebook.com/sharer/sharer.php?u=https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html&amp;title=Fast, High-Fidelity LLM Decoding with Regex Constraints" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
    <a href="https://plus.google.com/share?url=https://vivien000.github.io/blog/journal/llm-decoding-with-regex-constraints.html" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i></a>
  </div>
</div>



  <section class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = "unsupervisedthoughts";
    var disqus_identifier = "/journal/llm-decoding-with-regex-constraints.html";
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>



    </div>

    <footer class="footer">
  
  
  
    <a href="https://www.github.com/vivien000" target="_blank"><i class="fa fa-github" aria-hidden="true"></i></a>
  

  
  
    <a href="https://twitter.com/vivien000000" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  

  
  
    <a href="http://vivien000.github.io/blog/rss-feed.xml" target="_blank"><i class="fa fa-rss-square" aria-hidden="true"></i></a>
  

  
  
    <a href="mailto:vivien@melix.net" target="_blank"><i class="fa fa-envelope" aria-hidden="true"></i></a>
  

  <div class="post-date"><a href="https://vivien000.github.io/blog/menu/about.html">Unsupervised Thoughts | A blog on machine learning by Vivien</a></div>
</footer>


  </div>

</body>
</html>
